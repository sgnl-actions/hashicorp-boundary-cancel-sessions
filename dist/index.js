/**
 * @license MIT
 * Copyright (c) 2025 SGNL.ai, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
"use strict";class e extends Error{constructor(e){super(e),this.retryable=!0}}class t extends Error{constructor(e){super(e),this.retryable=!1}}var s={invoke:async(s,o)=>{console.log("Starting HashiCorp Boundary Cancel Sessions action");try{!function(e){if(!e.sessionId||"string"!=typeof e.sessionId||""===e.sessionId.trim())throw new t("Invalid or missing sessionId parameter");if(!e.authMethodId||"string"!=typeof e.authMethodId||""===e.authMethodId.trim())throw new t("Invalid or missing authMethodId parameter")}(s);const{sessionId:n,authMethodId:r}=s;if(console.log(`Processing session ID: ${n}`),!o.secrets?.BASIC_USERNAME||!o.secrets?.BASIC_PASSWORD)throw new t("Missing required secrets: BASIC_USERNAME and BASIC_PASSWORD");const a=function(e,t){const s=t.environment||{},o=e?.address||s.ADDRESS;if(!o)throw new Error("No URL specified. Provide address parameter or ADDRESS environment variable");return o.endsWith("/")?o.slice(0,-1):o}(s,o);console.log(`Authenticating with auth method: ${r}`);const i=await async function(s,o,n,r){const a=`${r}/v1/auth-methods/${encodeURIComponent(s)}:authenticate`,i=await fetch(a,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({attributes:{login_name:o,password:n}})});if(!i.ok){const s=await i.text();if(429===i.status)throw new e("Boundary API rate limit exceeded");if(401===i.status||403===i.status)throw new t("Invalid username or password");if(i.status>=500)throw new e(`Boundary API server error: ${i.status}`);throw new t(`Failed to authenticate: ${i.status} ${i.statusText} - ${s}`)}const c=await i.json();if(!c.attributes?.token)throw new t("No token returned from authentication");return c.attributes.token}(r,o.secrets.BASIC_USERNAME,o.secrets.BASIC_PASSWORD,a);await new Promise(e=>setTimeout(e,100)),console.log(`Getting session details for: ${n}`);const c=await async function(s,o,n){const r=`${n}/v1/sessions/${encodeURIComponent(s)}`,a=await fetch(r,{method:"GET",headers:{Authorization:`Bearer ${o}`,"Content-Type":"application/json"}});if(!a.ok){const o=await a.text();if(429===a.status)throw new e("Boundary API rate limit exceeded");if(401===a.status)throw new t("Invalid or expired authentication token");if(404===a.status)throw new t(`Session not found: ${s}`);if(a.status>=500)throw new e(`Boundary API server error: ${a.status}`);throw new t(`Failed to get session: ${a.status} ${a.statusText} - ${o}`)}const i=await a.json();if(!i.version)throw new t("No version returned from session");return i.version}(n,i,a);await new Promise(e=>setTimeout(e,100)),console.log(`Cancelling session: ${n} with version: ${c}`),await async function(s,o,n,r){const a=`${r}/v1/sessions/${encodeURIComponent(s)}:cancel`,i=await fetch(a,{method:"POST",headers:{Authorization:`Bearer ${n}`,"Content-Type":"application/json"},body:JSON.stringify({id:s,version:o})});if(!i.ok){const o=await i.text();if(429===i.status)throw new e("Boundary API rate limit exceeded");if(401===i.status)throw new t("Invalid or expired authentication token");if(404===i.status)throw new t(`Session not found: ${s}`);if(409===i.status)throw new t(`Session conflict (may already be cancelled): ${o}`);if(i.status>=500)throw new e(`Boundary API server error: ${i.status}`);throw new t(`Failed to cancel session: ${i.status} ${i.statusText} - ${o}`)}return!0}(n,c,i,a);const d={sessionId:n,authMethodId:r,sessionCancelled:!0,cancelledAt:(new Date).toISOString()};return console.log(`Successfully cancelled session: ${n}`),d}catch(s){if(console.error(`Error cancelling Boundary session: ${s.message}`),s instanceof e||s instanceof t)throw s;throw new t(`Unexpected error: ${s.message}`)}},error:async(e,t)=>{const{error:s}=e;throw console.error(`Error handler invoked: ${s?.message}`),s},halt:async(e,t)=>{const{reason:s,sessionId:o,authMethodId:n}=e;return console.log(`Job is being halted (${s})`),{sessionId:o||"unknown",authMethodId:n||"unknown",reason:s||"unknown",haltedAt:(new Date).toISOString(),cleanupCompleted:!0}}};module.exports=s;
