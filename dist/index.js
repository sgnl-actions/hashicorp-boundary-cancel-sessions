/**
 * @license MIT
 * Copyright (c) 2025 SGNL.ai, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
"use strict";const e="SGNL-CAEP-Hub/2.0";class t extends Error{constructor(e){super(e),this.retryable=!0}}class s extends Error{constructor(e){super(e),this.retryable=!1}}var n={invoke:async(n,o)=>{console.log("Starting HashiCorp Boundary Cancel Sessions action");try{!function(e){if(!e.sessionId||"string"!=typeof e.sessionId||""===e.sessionId.trim())throw new s("Invalid or missing sessionId parameter");if(!e.authMethodId||"string"!=typeof e.authMethodId||""===e.authMethodId.trim())throw new s("Invalid or missing authMethodId parameter")}(n);const{sessionId:r,authMethodId:a}=n;if(console.log(`Processing session ID: ${r}`),!o.secrets?.BASIC_USERNAME||!o.secrets?.BASIC_PASSWORD)throw new s("Missing required secrets: BASIC_USERNAME and BASIC_PASSWORD");const i=function(e,t){const s=t.environment||{},n=e?.address||s.ADDRESS;if(!n)throw new Error("No URL specified. Provide address parameter or ADDRESS environment variable");return n.endsWith("/")?n.slice(0,-1):n}(n,o);console.log(`Authenticating with auth method: ${a}`);const c=await async function(n,o,r,a){const i=`${a}/v1/auth-methods/${encodeURIComponent(n)}:authenticate`,c=await fetch(i,{method:"POST",headers:{"Content-Type":"application/json","User-Agent":e},body:JSON.stringify({attributes:{login_name:o,password:r}})});if(!c.ok){const e=await c.text();if(429===c.status)throw new t("Boundary API rate limit exceeded");if(401===c.status||403===c.status)throw new s("Invalid username or password");if(c.status>=500)throw new t(`Boundary API server error: ${c.status}`);throw new s(`Failed to authenticate: ${c.status} ${c.statusText} - ${e}`)}const d=await c.json();if(!d.attributes?.token)throw new s("No token returned from authentication");return d.attributes.token}(a,o.secrets.BASIC_USERNAME,o.secrets.BASIC_PASSWORD,i);await new Promise(e=>setTimeout(e,100)),console.log(`Getting session details for: ${r}`);const d=await async function(n,o,r){const a=`${r}/v1/sessions/${encodeURIComponent(n)}`,i=await fetch(a,{method:"GET",headers:{Authorization:`Bearer ${o}`,"Content-Type":"application/json","User-Agent":e}});if(!i.ok){const e=await i.text();if(429===i.status)throw new t("Boundary API rate limit exceeded");if(401===i.status)throw new s("Invalid or expired authentication token");if(404===i.status)throw new s(`Session not found: ${n}`);if(i.status>=500)throw new t(`Boundary API server error: ${i.status}`);throw new s(`Failed to get session: ${i.status} ${i.statusText} - ${e}`)}const c=await i.json();if(!c.version)throw new s("No version returned from session");return c.version}(r,c,i);await new Promise(e=>setTimeout(e,100)),console.log(`Cancelling session: ${r} with version: ${d}`),await async function(n,o,r,a){const i=`${a}/v1/sessions/${encodeURIComponent(n)}:cancel`,c=await fetch(i,{method:"POST",headers:{Authorization:`Bearer ${r}`,"Content-Type":"application/json","User-Agent":e},body:JSON.stringify({id:n,version:o})});if(!c.ok){const e=await c.text();if(429===c.status)throw new t("Boundary API rate limit exceeded");if(401===c.status)throw new s("Invalid or expired authentication token");if(404===c.status)throw new s(`Session not found: ${n}`);if(409===c.status)throw new s(`Session conflict (may already be cancelled): ${e}`);if(c.status>=500)throw new t(`Boundary API server error: ${c.status}`);throw new s(`Failed to cancel session: ${c.status} ${c.statusText} - ${e}`)}return!0}(r,d,c,i);const u={sessionId:r,authMethodId:a,sessionCancelled:!0,cancelledAt:(new Date).toISOString()};return console.log(`Successfully cancelled session: ${r}`),u}catch(e){if(console.error(`Error cancelling Boundary session: ${e.message}`),e instanceof t||e instanceof s)throw e;throw new s(`Unexpected error: ${e.message}`)}},error:async(e,t)=>{const{error:s}=e;throw console.error(`Error handler invoked: ${s?.message}`),s},halt:async(e,t)=>{const{reason:s,sessionId:n,authMethodId:o}=e;return console.log(`Job is being halted (${s})`),{sessionId:n||"unknown",authMethodId:o||"unknown",reason:s||"unknown",haltedAt:(new Date).toISOString(),cleanupCompleted:!0}}};module.exports=n;
